<?xml version="1.0" encoding="UTF-8"?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0">
  <info>
    <title>Vimで選択した行の順番を入れ替える</title>
    <abstract>
      Vim で選択した行の順番を入れ替える方法。
    </abstract>
    <keywordset>
      <keyword>vim</keyword>
    </keywordset>
    <revhistory>
      <revision>
        <date>2021-10-02</date>
        <revremark>Qiita から移植</revremark>
      </revision>
    </revhistory>
  </info>
  <simpara>この記事は Qiita から移植してきたものです。 元 URL:
  <link xl:href="https://qiita.com/nsfisis/items/4fefb361d9a693803520">https://qiita.com/nsfisis/items/4fefb361d9a693803520</link></simpara>
<simpara><hr/></simpara>
<section xml:id="_バージョン情報">
  <title>バージョン情報</title>
  <simpara><literal>:version</literal> の一部</simpara>
  <blockquote>
    <simpara>VIM - Vi IMproved 8.2 (2019 Dec 12, compiled Jan 26 2020 11:30:30) macOS
    version Included patches: 1-148 Huge version without GUI.</simpara>
</blockquote>
</section>
<section xml:id="_よく紹介されている手法">
  <title>よく紹介されている手法</title>
  <section xml:id="_tac_tail">
    <title><literal>tac</literal> / <literal>tail</literal></title>
    <simpara><literal>tac</literal> や <literal>tail -r</literal> などの外部コマンドを <literal>!</literal>
      を使って呼び出し、置き換える。</simpara>
    <blockquote>
      <simpara>:h v_!</simpara>
    </blockquote>
    <simpara><literal>tac</literal> コマンドや <literal>tail</literal> の <literal>-r</literal>
      オプションは環境によって利用できないことがあり、複数の環境を行き来する場合に採用しづらい</simpara>
  </section>
  <section xml:id="_gm0">
    <title><literal>:g/^/m0</literal></title>
    <simpara>こちらは外部コマンドに頼らず、Vim の機能のみを使う。<literal>g</literal> は <literal>:global</literal>
      コマンドの、<literal>m</literal> は <literal>:move</literal> コマンドの略</simpara>
    <simpara><literal>:global</literal> コマンドは <literal>:[range]global/{pattern}/[command]</literal>
      のように使い、<literal>[range]</literal> で指定された範囲の行のうち、<literal>{pattern}</literal>
      で指定された検索パターンにマッチする行に対して、順番に <literal>[command]</literal>
      で指定された Ex コマンドを呼び出す。</simpara>
    <blockquote>
      <simpara>:h :global</simpara>
    </blockquote>
    <simpara><literal>:move</literal> コマンドは <literal>[range]:move {address}</literal> のように使い、<literal>[range]</literal>
      で指定された範囲の行を <literal>{address}</literal> で指定された位置に移動させる。</simpara>
    <blockquote>
      <simpara>:h :move</simpara>
    </blockquote>
    <simpara><literal>:g/^/m0</literal> のように組み合わせると、「すべての行を1行ずつ
    0行目(1行目の上)に動かす」という動きをする。これは確かに行の入れ替えになっている。</simpara>
  <simpara>なお、<literal>:g/^/m0</literal> は全ての行を入れ替えるが、<literal>:N,Mg/^/mN-1</literal> とすることで
  N行目から
  M行目を処理範囲とするよう拡張できる。手でこれを入力するわけにはいかないので、次のようなコマンドを用意する。</simpara>
<programlisting language="vim" linenumbering="unnumbered">command! -bar -range=%
\ Reverse
\ &lt;line1&gt;,&lt;line2&gt;g/^/m&lt;line1&gt;-1</programlisting>
<simpara>これは望みの動作をするが、実際に実行してみると全行がハイライトされてしまう。次節で詳細を述べる。</simpara>
</section>
</section>
<section xml:id="_gm0_の問題点">
  <title><literal>:g/^/m0</literal> の問題点</title>
  <simpara><literal>:global</literal>
    コマンドは各行に対してマッチングを行う際、現在の検索パターンを上書きしてしまう。<literal>^</literal>
    は行の先頭にマッチするため、結果として全ての行がハイライトされてしまう。<literal>'hlsearch'</literal>
    オプションを無効にしている場合その限りではないが、その場合でも直前の検索パターンが失われてしまうと
    <literal>n</literal> コマンドなどの際に不便である。</simpara>
  <blockquote>
    <simpara>:h @/</simpara>
  </blockquote>
</section>
<section xml:id="_解決策">
  <title>解決策</title>
  <blockquote>
    <simpara>[2020/9/28追記] より簡潔な方法を見つけたので次節に追記した</simpara>
  </blockquote>
  <simpara>前述した <literal>:Reverse</literal> コマンドの定義を少し変えて、次のようにする:</simpara>
  <programlisting language="vim" linenumbering="unnumbered">function! s:reverse_lines(from, to) abort
  execute printf("%d,%dg/^/m%d", a:from, a:to, a:from - 1)
  endfunction

  command! -bar -range=%
  \ Reverse
  \ call &lt;SID&gt;reverse_lines(&lt;line1&gt;, &lt;line2&gt;)</programlisting>
<simpara>実行しているコマンドが変わったわけではないが、関数呼び出しを経由するようにした。これだけで前述の問題が解決する。</simpara>
<simpara>この理由は、ユーザー定義関数を実行する際は検索パターンが一度保存され、実行が終了したあと復元されるため。結果として検索パターンが
<literal>^</literal> で上書きされることがなくなる。</simpara>
<simpara>Vim のヘルプから該当箇所を引用する (強調は筆者による)。</simpara>
<blockquote>
  <simpara>:h autocmd-searchpat</simpara>
  <simpara><emphasis role="strong">Autocommands do not change the current search patterns.</emphasis> Vim saves the
  current search patterns before executing autocommands then restores them
  after the autocommands finish. This means that autocommands do not
  affect the strings highlighted with the `hlsearch' option.</simpara>
</blockquote>
<simpara>これは autocommand
の実行に関しての記述だが、これと同じことがユーザー定義関数の実行時にも適用される。このことは
<literal>:nohlsearch</literal> のヘルプにある。同じく該当箇所を引用する
(強調は筆者による)。</simpara>
<blockquote>
  <simpara>:h :nohlsearch</simpara>
  <simpara>(略) This command doesn’t work in an autocommand, because the
  highlighting state is saved and restored when executing autocommands
  |autocmd-searchpat|. <emphasis role="strong">Same thing for when invoking a user function.</emphasis></simpara>
</blockquote>
<simpara>この仕様により、<literal>:g/^/m0</literal>
  の呼び出しをユーザー定義関数に切り出すことで上述の問題を解決できる。</simpara>
</section>
<section xml:id="_解決策_改訂版">
  <title>解決策 (改訂版)</title>
  <blockquote>
    <simpara>[2020/9/28追記] より簡潔な方法を見つけたため追記する</simpara>
  </blockquote>
  <programlisting language="vim" linenumbering="unnumbered">command! -bar -range=%
  \ Reverse
  \ keeppatterns &lt;line1&gt;,&lt;line2&gt;g/^/m&lt;line1&gt;-1</programlisting>
<simpara>まさにこのための Exコマンド、<literal>:keeppatterns</literal>
  が存在する。<literal>:keeppatterns {command}</literal>
  のように使い、読んで字の如く、後ろに続く
  Exコマンドを「現在の検索パターンを保ったまま」実行する。はるかに分かりやすく意図を表現できる。</simpara>
<blockquote>
  <simpara>:h :keeppatterns</simpara>
</blockquote>
</section>
<section xml:id="_コピペ用再掲">
  <title>コピペ用再掲</title>
  <programlisting language="vim" linenumbering="unnumbered">" License: Public Domain

  command! -bar -range=%
  \ Reverse
  \ keeppatterns &lt;line1&gt;,&lt;line2&gt;g/^/m&lt;line1&gt;-1</programlisting>
</section>
</article>
